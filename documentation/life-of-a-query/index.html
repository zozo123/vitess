<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Life of A Query • Vitess</title>
    <meta name="description" content="Life of A Query


From Client to VtGate
From VtGate to VtTablet
From VtTablet to MySQL
Put it all together
TopoServer
Streaming Query
Scatter Query
Misc


Rpc Server Code Path (VtGate)
VtGate to VtTablet Code Path
VtTablet to MySQL Code Path



A query means a request for information from database and it involves four componenets in the case of Vitess, including client application, VtGate, VtTablet and MySQL instance. This doc explains interaction happens between and within components.



At a very high level, as the graph shows, first client sends a query to VtGate. VtGate then resolves the query and routes it to the right VtTablets. For each VtTablet that receives the query, it does necessary validations and passes the query to underlying MySQL instance. After gathering results from MySQL, VtTablet sends response back to VtGate. Once VtGate receives response from all VtTablets, it sends the combined result to client. In the presence of VtTablet errors, VtGate will retry the query if errors are recoverable and it only fails the query if either errors are unrecoverable or maximum retry times has been reached.

From Client to VtGate

A client application first sends a bson rpc with an embedded sql query to VtGate. VtGate&#39;s rpc server unmarshals this rpc request, call appropriate VtGate method and return its result back to client. As following graph shows, VtGate has a rpc server that listens to localhost:port/_bson_rpc_ for http requests and localhost:port/_bson_rpc_/auth for https requests.



VtGate keeps an in-memory table that stores all available rpc methods for each service, e.g. VtGate uses &quot;VTGate&quot; as its service name and most its methods defined in go/vt/vtgate/vtgate.go are used to serve rpc request go/rpcplus/server.go.

From VtGate to VtTablet



After receiving a rpc call from client and one of its Execute* method being invoked, VtGate needs to figure out which shards should receive the query and send query to each of them. In addition, VtGate talks to topo server to get necessary information to create a VtTablet connection for each shard. At this point, VtGate is able to send query to the right VtTablets in parallel. VtGate also does retry if timeout happens or some VtTablets return recoverable errors.

Internally, VtGate has a ScatterConn instance and uses it to execute queries across multiple ShardConn connections. A ScatterConn performs the query on selected shards in parallel. It first obtains a ShardConn connection for every shard and sends query use ShardConn&#39;s execute method. If the requested session is in a transaction, it will open a new transactions on the connection, and updates the Session with the transaction id. If the session already contains a transaction id for the shard, it reuses it. If there are any unrecoverable errors during a transaction, it rolls back the transaction for all shards.

A ShardConn object represents a load balanced connection to a group of VtTablets that belong the same shard. ShardConn can be concurrently used across goroutines.

From VtTablet to MySQL



Once received a rpc call from VtGate, VtTablet do a few checks before passing query to MySQL. It first validates the current VtTablet state including sessions id, then generates a query plan and applies predefined query rules and do ACL check. It also checks whether the query hits row cache and returns result immediately if so. In addition, VtTablet consolidates duplicate queries from executing simultaneously and shares results between them. At this point, VtTablet has no way but pass the query down to MySQL layer and waits for the result.

Put it all together



TopoServer

A topo server stores information to help VtGate navigate query to the right VtTablets. It contains keyspace to shards mappings, keyspace id to shard mapping and ports that a VtTablet listens to (EndPoint). VtGates caches those information in the memory and periodically do updates if there are changes happened in the topo server.

Streaming Query

In general speaking, a streaming query means query results will be returned as a stream. In Vitess&#39;s case, both VtGate and VtTablet will send result back as soon as it is available. VtTablet by default will collect a fixed number of rows returned from MySQL, send them back to VtGate and repeats the above step until all rows have been returned.

Scatter Query

A scatter query, as its name indicates, will hit multiple shards. In Vitess, a scatter query is recognized once VtGate determines a query need to hit multiple VtTablets. VtGate then sends query to these VtTablets, assembles the result after receiving all response and returns the combined result to the client.

Misc

Rpc Server Code Path (VtGate)

Init a rpc server
go/cmd/vtgate/vtgate.go: main()  -&gt;
  go/vt/servenv/servenv.go: RunDefault() -&gt; // use the port specified in command line &quot;--port&quot;
    go/vt/servenv/run.go: Run(port int)  -&gt;
      go/vt/servenv/rpc.go: ServeRPC()  -&gt; // set up rpc server
        go/rpcwrap/bsonrpc/codec.go: ServeRPC()  -&gt; // set up bson rpc server
          go/rpcwrap/rpcwrap.go: ServeRPC(&quot;bson&quot;, NewServerCodec)  -&gt; // common code to register rpc server

ServeRPC(&quot;bson&quot;, NewServerCodec) register a rpcHandler instance whose ServeHTTP(http.ResponseWriter, *http.Request) will be called for every http request

Rpc server handle http request
go/rpcwrap/rpcwrap.go rpcHandler.ServeHTTP -&gt;
go/rpcwrap/rpcwrap.go rpcHandler.server.ServeCodecWithContext -&gt;
go/rpcplus/server.go Server.ServeCodecWithContext(context.Context, ServerCodec) (note: rpcHandler uses a global DefaultServer instance defined in the sever.go) -&gt;
go/rpcplus/server.go Server.readRequest(ServeCodec) will use a given codec to extract (service, methodType, request, request arguments, reply value, keep reading), go/rpcplus/server.go
Finally we do &quot;service.call(..)&quot; with parameters provided in the request. In the current setup, service.call will always call some method in VtGate (go/vt/vtgate/vtgate.go).

VtGate to VtTablet Code Path

Here is the code path for a query with keyspace id.
go/vt/vtgate/vtgate.go VTGate.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery, *proto.QueryResult) -&gt;
  go/vt/vtgate/resolver.go resolver.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery) -&gt;
    go/vt/vtgate/resolver.go resolver.Execute -&gt;
      go/vt/vtgate/scatter_conn.go ScatterConn.Execute -&gt;
        go/vt/vtgate/scatter_conn.go ScatterConn.multiGo -&gt;
          go/vt/vtgate/scatter_conn.go ScatterConn.getConnection -&gt;
          go/vt/vtgate/shard_conn.go ShardConn.Execute -&gt;
            go/vt/vtgate/shard_conn.go ShardConn.withRetry -&gt;
              go/vt/vtgate/shard_conn.go ShardConn.getConn -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.GetDialer -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.TabletConn.Execute -&gt;
              go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.Execute -&gt;
                go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.rpcClient.Call -&gt;
                go/rpcplus/client.go rpcplus.Client.Call -&gt;
                  go/rpcplus/client.go rpcplus.Client.Go -&gt;
                    go/rpcplus/client.go rpcplus.Client.send

VtTablet to MySQL Code Path

Here is the code path for a select query.
go/vt/tabletserver/sqlquery.go SqlQuery.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.execSelect -&gt;
go/vt/tabletserver/request_context.go RequestContext.getConn -&gt; // QueryExecutor composes a RequestContext
go/vt/tabletserver/request_context.go RequestContext.fullFetch -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQL -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLNoPanic -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLOnce -&gt;
go/vt/dbconnpool/connection_pool.go PoolConnection.ExecuteFetch (current implementation is in DBConnection) -&gt;
go/vt/dbconnpool/connection.go PooledConnection.DBConnection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.fetchAll
">
    <meta name="keywords" content="query">
    
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="Life of A Query">
	<meta name="twitter:description" content="Life of A Query


From Client to VtGate
From VtGate to VtTablet
From VtTablet to MySQL
Put it all together
TopoServer
Streaming Query
Scatter Query
Misc


Rpc Server Code Path (VtGate)
VtGate to VtTablet Code Path
VtTablet to MySQL Code Path



A query means a request for information from database and it involves four componenets in the case of Vitess, including client application, VtGate, VtTablet and MySQL instance. This doc explains interaction happens between and within components.



At a very high level, as the graph shows, first client sends a query to VtGate. VtGate then resolves the query and routes it to the right VtTablets. For each VtTablet that receives the query, it does necessary validations and passes the query to underlying MySQL instance. After gathering results from MySQL, VtTablet sends response back to VtGate. Once VtGate receives response from all VtTablets, it sends the combined result to client. In the presence of VtTablet errors, VtGate will retry the query if errors are recoverable and it only fails the query if either errors are unrecoverable or maximum retry times has been reached.

From Client to VtGate

A client application first sends a bson rpc with an embedded sql query to VtGate. VtGate&#39;s rpc server unmarshals this rpc request, call appropriate VtGate method and return its result back to client. As following graph shows, VtGate has a rpc server that listens to localhost:port/_bson_rpc_ for http requests and localhost:port/_bson_rpc_/auth for https requests.



VtGate keeps an in-memory table that stores all available rpc methods for each service, e.g. VtGate uses &quot;VTGate&quot; as its service name and most its methods defined in go/vt/vtgate/vtgate.go are used to serve rpc request go/rpcplus/server.go.

From VtGate to VtTablet



After receiving a rpc call from client and one of its Execute* method being invoked, VtGate needs to figure out which shards should receive the query and send query to each of them. In addition, VtGate talks to topo server to get necessary information to create a VtTablet connection for each shard. At this point, VtGate is able to send query to the right VtTablets in parallel. VtGate also does retry if timeout happens or some VtTablets return recoverable errors.

Internally, VtGate has a ScatterConn instance and uses it to execute queries across multiple ShardConn connections. A ScatterConn performs the query on selected shards in parallel. It first obtains a ShardConn connection for every shard and sends query use ShardConn&#39;s execute method. If the requested session is in a transaction, it will open a new transactions on the connection, and updates the Session with the transaction id. If the session already contains a transaction id for the shard, it reuses it. If there are any unrecoverable errors during a transaction, it rolls back the transaction for all shards.

A ShardConn object represents a load balanced connection to a group of VtTablets that belong the same shard. ShardConn can be concurrently used across goroutines.

From VtTablet to MySQL



Once received a rpc call from VtGate, VtTablet do a few checks before passing query to MySQL. It first validates the current VtTablet state including sessions id, then generates a query plan and applies predefined query rules and do ACL check. It also checks whether the query hits row cache and returns result immediately if so. In addition, VtTablet consolidates duplicate queries from executing simultaneously and shares results between them. At this point, VtTablet has no way but pass the query down to MySQL layer and waits for the result.

Put it all together



TopoServer

A topo server stores information to help VtGate navigate query to the right VtTablets. It contains keyspace to shards mappings, keyspace id to shard mapping and ports that a VtTablet listens to (EndPoint). VtGates caches those information in the memory and periodically do updates if there are changes happened in the topo server.

Streaming Query

In general speaking, a streaming query means query results will be returned as a stream. In Vitess&#39;s case, both VtGate and VtTablet will send result back as soon as it is available. VtTablet by default will collect a fixed number of rows returned from MySQL, send them back to VtGate and repeats the above step until all rows have been returned.

Scatter Query

A scatter query, as its name indicates, will hit multiple shards. In Vitess, a scatter query is recognized once VtGate determines a query need to hit multiple VtTablets. VtGate then sends query to these VtTablets, assembles the result after receiving all response and returns the combined result to the client.

Misc

Rpc Server Code Path (VtGate)

Init a rpc server
go/cmd/vtgate/vtgate.go: main()  -&gt;
  go/vt/servenv/servenv.go: RunDefault() -&gt; // use the port specified in command line &quot;--port&quot;
    go/vt/servenv/run.go: Run(port int)  -&gt;
      go/vt/servenv/rpc.go: ServeRPC()  -&gt; // set up rpc server
        go/rpcwrap/bsonrpc/codec.go: ServeRPC()  -&gt; // set up bson rpc server
          go/rpcwrap/rpcwrap.go: ServeRPC(&quot;bson&quot;, NewServerCodec)  -&gt; // common code to register rpc server

ServeRPC(&quot;bson&quot;, NewServerCodec) register a rpcHandler instance whose ServeHTTP(http.ResponseWriter, *http.Request) will be called for every http request

Rpc server handle http request
go/rpcwrap/rpcwrap.go rpcHandler.ServeHTTP -&gt;
go/rpcwrap/rpcwrap.go rpcHandler.server.ServeCodecWithContext -&gt;
go/rpcplus/server.go Server.ServeCodecWithContext(context.Context, ServerCodec) (note: rpcHandler uses a global DefaultServer instance defined in the sever.go) -&gt;
go/rpcplus/server.go Server.readRequest(ServeCodec) will use a given codec to extract (service, methodType, request, request arguments, reply value, keep reading), go/rpcplus/server.go
Finally we do &quot;service.call(..)&quot; with parameters provided in the request. In the current setup, service.call will always call some method in VtGate (go/vt/vtgate/vtgate.go).

VtGate to VtTablet Code Path

Here is the code path for a query with keyspace id.
go/vt/vtgate/vtgate.go VTGate.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery, *proto.QueryResult) -&gt;
  go/vt/vtgate/resolver.go resolver.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery) -&gt;
    go/vt/vtgate/resolver.go resolver.Execute -&gt;
      go/vt/vtgate/scatter_conn.go ScatterConn.Execute -&gt;
        go/vt/vtgate/scatter_conn.go ScatterConn.multiGo -&gt;
          go/vt/vtgate/scatter_conn.go ScatterConn.getConnection -&gt;
          go/vt/vtgate/shard_conn.go ShardConn.Execute -&gt;
            go/vt/vtgate/shard_conn.go ShardConn.withRetry -&gt;
              go/vt/vtgate/shard_conn.go ShardConn.getConn -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.GetDialer -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.TabletConn.Execute -&gt;
              go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.Execute -&gt;
                go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.rpcClient.Call -&gt;
                go/rpcplus/client.go rpcplus.Client.Call -&gt;
                  go/rpcplus/client.go rpcplus.Client.Go -&gt;
                    go/rpcplus/client.go rpcplus.Client.send

VtTablet to MySQL Code Path

Here is the code path for a select query.
go/vt/tabletserver/sqlquery.go SqlQuery.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.execSelect -&gt;
go/vt/tabletserver/request_context.go RequestContext.getConn -&gt; // QueryExecutor composes a RequestContext
go/vt/tabletserver/request_context.go RequestContext.fullFetch -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQL -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLNoPanic -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLOnce -&gt;
go/vt/dbconnpool/connection_pool.go PoolConnection.ExecuteFetch (current implementation is in DBConnection) -&gt;
go/vt/dbconnpool/connection.go PooledConnection.DBConnection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.fetchAll
">
	
	
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:image" content="http://youtube.github.io/vitess/images/120x120.gif">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="en_US">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Life of A Query">
	<meta property="og:description" content="Life of A Query


From Client to VtGate
From VtGate to VtTablet
From VtTablet to MySQL
Put it all together
TopoServer
Streaming Query
Scatter Query
Misc


Rpc Server Code Path (VtGate)
VtGate to VtTablet Code Path
VtTablet to MySQL Code Path



A query means a request for information from database and it involves four componenets in the case of Vitess, including client application, VtGate, VtTablet and MySQL instance. This doc explains interaction happens between and within components.



At a very high level, as the graph shows, first client sends a query to VtGate. VtGate then resolves the query and routes it to the right VtTablets. For each VtTablet that receives the query, it does necessary validations and passes the query to underlying MySQL instance. After gathering results from MySQL, VtTablet sends response back to VtGate. Once VtGate receives response from all VtTablets, it sends the combined result to client. In the presence of VtTablet errors, VtGate will retry the query if errors are recoverable and it only fails the query if either errors are unrecoverable or maximum retry times has been reached.

From Client to VtGate

A client application first sends a bson rpc with an embedded sql query to VtGate. VtGate&#39;s rpc server unmarshals this rpc request, call appropriate VtGate method and return its result back to client. As following graph shows, VtGate has a rpc server that listens to localhost:port/_bson_rpc_ for http requests and localhost:port/_bson_rpc_/auth for https requests.



VtGate keeps an in-memory table that stores all available rpc methods for each service, e.g. VtGate uses &quot;VTGate&quot; as its service name and most its methods defined in go/vt/vtgate/vtgate.go are used to serve rpc request go/rpcplus/server.go.

From VtGate to VtTablet



After receiving a rpc call from client and one of its Execute* method being invoked, VtGate needs to figure out which shards should receive the query and send query to each of them. In addition, VtGate talks to topo server to get necessary information to create a VtTablet connection for each shard. At this point, VtGate is able to send query to the right VtTablets in parallel. VtGate also does retry if timeout happens or some VtTablets return recoverable errors.

Internally, VtGate has a ScatterConn instance and uses it to execute queries across multiple ShardConn connections. A ScatterConn performs the query on selected shards in parallel. It first obtains a ShardConn connection for every shard and sends query use ShardConn&#39;s execute method. If the requested session is in a transaction, it will open a new transactions on the connection, and updates the Session with the transaction id. If the session already contains a transaction id for the shard, it reuses it. If there are any unrecoverable errors during a transaction, it rolls back the transaction for all shards.

A ShardConn object represents a load balanced connection to a group of VtTablets that belong the same shard. ShardConn can be concurrently used across goroutines.

From VtTablet to MySQL



Once received a rpc call from VtGate, VtTablet do a few checks before passing query to MySQL. It first validates the current VtTablet state including sessions id, then generates a query plan and applies predefined query rules and do ACL check. It also checks whether the query hits row cache and returns result immediately if so. In addition, VtTablet consolidates duplicate queries from executing simultaneously and shares results between them. At this point, VtTablet has no way but pass the query down to MySQL layer and waits for the result.

Put it all together



TopoServer

A topo server stores information to help VtGate navigate query to the right VtTablets. It contains keyspace to shards mappings, keyspace id to shard mapping and ports that a VtTablet listens to (EndPoint). VtGates caches those information in the memory and periodically do updates if there are changes happened in the topo server.

Streaming Query

In general speaking, a streaming query means query results will be returned as a stream. In Vitess&#39;s case, both VtGate and VtTablet will send result back as soon as it is available. VtTablet by default will collect a fixed number of rows returned from MySQL, send them back to VtGate and repeats the above step until all rows have been returned.

Scatter Query

A scatter query, as its name indicates, will hit multiple shards. In Vitess, a scatter query is recognized once VtGate determines a query need to hit multiple VtTablets. VtGate then sends query to these VtTablets, assembles the result after receiving all response and returns the combined result to the client.

Misc

Rpc Server Code Path (VtGate)

Init a rpc server
go/cmd/vtgate/vtgate.go: main()  -&gt;
  go/vt/servenv/servenv.go: RunDefault() -&gt; // use the port specified in command line &quot;--port&quot;
    go/vt/servenv/run.go: Run(port int)  -&gt;
      go/vt/servenv/rpc.go: ServeRPC()  -&gt; // set up rpc server
        go/rpcwrap/bsonrpc/codec.go: ServeRPC()  -&gt; // set up bson rpc server
          go/rpcwrap/rpcwrap.go: ServeRPC(&quot;bson&quot;, NewServerCodec)  -&gt; // common code to register rpc server

ServeRPC(&quot;bson&quot;, NewServerCodec) register a rpcHandler instance whose ServeHTTP(http.ResponseWriter, *http.Request) will be called for every http request

Rpc server handle http request
go/rpcwrap/rpcwrap.go rpcHandler.ServeHTTP -&gt;
go/rpcwrap/rpcwrap.go rpcHandler.server.ServeCodecWithContext -&gt;
go/rpcplus/server.go Server.ServeCodecWithContext(context.Context, ServerCodec) (note: rpcHandler uses a global DefaultServer instance defined in the sever.go) -&gt;
go/rpcplus/server.go Server.readRequest(ServeCodec) will use a given codec to extract (service, methodType, request, request arguments, reply value, keep reading), go/rpcplus/server.go
Finally we do &quot;service.call(..)&quot; with parameters provided in the request. In the current setup, service.call will always call some method in VtGate (go/vt/vtgate/vtgate.go).

VtGate to VtTablet Code Path

Here is the code path for a query with keyspace id.
go/vt/vtgate/vtgate.go VTGate.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery, *proto.QueryResult) -&gt;
  go/vt/vtgate/resolver.go resolver.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery) -&gt;
    go/vt/vtgate/resolver.go resolver.Execute -&gt;
      go/vt/vtgate/scatter_conn.go ScatterConn.Execute -&gt;
        go/vt/vtgate/scatter_conn.go ScatterConn.multiGo -&gt;
          go/vt/vtgate/scatter_conn.go ScatterConn.getConnection -&gt;
          go/vt/vtgate/shard_conn.go ShardConn.Execute -&gt;
            go/vt/vtgate/shard_conn.go ShardConn.withRetry -&gt;
              go/vt/vtgate/shard_conn.go ShardConn.getConn -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.GetDialer -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.TabletConn.Execute -&gt;
              go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.Execute -&gt;
                go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.rpcClient.Call -&gt;
                go/rpcplus/client.go rpcplus.Client.Call -&gt;
                  go/rpcplus/client.go rpcplus.Client.Go -&gt;
                    go/rpcplus/client.go rpcplus.Client.send

VtTablet to MySQL Code Path

Here is the code path for a select query.
go/vt/tabletserver/sqlquery.go SqlQuery.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.execSelect -&gt;
go/vt/tabletserver/request_context.go RequestContext.getConn -&gt; // QueryExecutor composes a RequestContext
go/vt/tabletserver/request_context.go RequestContext.fullFetch -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQL -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLNoPanic -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLOnce -&gt;
go/vt/dbconnpool/connection_pool.go PoolConnection.ExecuteFetch (current implementation is in DBConnection) -&gt;
go/vt/dbconnpool/connection.go PooledConnection.DBConnection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.fetchAll
">
	<meta property="og:url" content="http://youtube.github.io/vitess/documentation/life-of-a-query/">
	<meta property="og:site_name" content="Vitess">

    <link rel="canonical" href="http://youtube.github.io/vitess/documentation/life-of-a-query/">

    <link href="http://youtube.github.io/vitess/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">

    <style>
    .sliding-menu-content {
      top: 0;
      right: 0;
      text-align: center;
      visibility: hidden;
      height: 100%;
      width: 100%;
      -webkit-transform: translateX(100%);
      -moz-transform: translateX(100%);
      -ms-transform: translateX(100%);
      -o-transform: translateX(100%);
      transform: translateX(100%);
    }
    </style>

    <link rel="stylesheet" href="http://youtube.github.io/vitess/css/main.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="http://youtube.github.io/vitess/js/vendor/html5shiv.min.js"></script>
      <script src="http://youtube.github.io/vitess/js/vendor/respond.min.js"></script>
    <![endif]-->

  </head>

  <body>
    <header id="masthead">
  <div class="inner-wrap">
    <a href="http://youtube.github.io/vitess/" class="site-title">Vitess</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Vitess</a></li>
	
    
        
    
    <li><a href="http://youtube.github.io/vitess/getting-started/" >Getting Started</a></li>
  
    
        
    
    <li><a href="http://youtube.github.io/vitess/documentation/" >Documentation</a></li>
  
    
        
    
    <li><a href="http://youtube.github.io/vitess/about/" >About</a></li>
  
    
        
    
    <li><a href="http://youtube.github.io/vitess/faq/" >FAQ</a></li>
  
</ul>
    </nav>
  </div>
</header>

    <nav role="navigation" class="js-menu sliding-menu-content">
	<ul class="menu-item">
		<li>
      
        
      
			<a href="http://youtube.github.io/vitess/getting-started/"><img src="http://youtube.github.io/vitess/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://youtube.github.io/vitess/getting-started/" class="title">Getting Started</a>
			<p class="excerpt">Everything you need to know to get started with Vitess.</p>
		</li><li>
      
        
      
			<a href="http://youtube.github.io/vitess/documentation/"><img src="http://youtube.github.io/vitess/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://youtube.github.io/vitess/documentation/" class="title">Documentation</a>
			<p class="excerpt">Vitess Docs.</p>
		</li><li>
      
        
      
			<a href="http://youtube.github.io/vitess/about/"><img src="http://youtube.github.io/vitess/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://youtube.github.io/vitess/about/" class="title">About</a>
			<p class="excerpt">All about Vitess.</p>
		</li><li>
      
        
      
			<a href="http://youtube.github.io/vitess/faq/"><img src="http://youtube.github.io/vitess/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://youtube.github.io/vitess/faq/" class="title">FAQ</a>
			<p class="excerpt">Vitess Faq.</p>
		</li>
	</ul>
</nav>
<button type="button" class="js-menu-trigger sliding-menu-button menulines-button x2" role="button" aria-label="Toggle Navigation">
	<span class="menulines"></span>
</button>

<div class="js-menu-screen menu-screen"></div>

    <div id="page-wrapper">
      <!--[if lt IE 9]><div class="upgrade notice-danger"><strong>Your browser is quite old!</strong> Why not <a href="http://whatbrowser.org/">upgrade to a newer one</a> to better enjoy this site?</div><![endif]-->

      <div id="main" role="main">
  <article class="wrap" itemscope itemtype="http://schema.org/Article">
    
    
  <nav class="breadcrumbs">
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://youtube.github.io/vitess" itemprop="url">
        <span itemprop="title">Home</span>
      </a> › 
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://youtube.github.io/vitess/documentation/" itemprop="url">
        <span itemprop="title">Documentation</span>
      </a>
    </span>
  </nav>


    <div class="inner-wrap">
      <nav class="toc"></nav>
      <div id="content" class="page-content" itemprop="articleBody">
	<h1 id="life-of-a-query">Life of A Query</h1>

<ul>
<li><a href="#from-client-to-vtgate">From Client to VtGate</a></li>
<li><a href="#from-vtgate-to-vttablet">From VtGate to VtTablet</a></li>
<li><a href="#from-vttablet-to-mysql">From VtTablet to MySQL</a></li>
<li><a href="#put-it-all-together">Put it all together</a></li>
<li><a href="#toposerver">TopoServer</a></li>
<li><a href="#streaming-query">Streaming Query</a></li>
<li><a href="#scatter-query">Scatter Query</a></li>
<li><a href="#misc">Misc</a>

<ul>
<li><a href="#rpc-server-code-path-vtgate">Rpc Server Code Path (VtGate)</a></li>
<li><a href="#vtgate-to-vttablet-code-path">VtGate to VtTablet Code Path</a></li>
<li><a href="#vttablet-to-mysql-code-path">VtTablet to MySQL Code Path</a></li>
</ul></li>
</ul>

<p>A query means a request for information from database and it involves four componenets in the case of Vitess, including client application, VtGate, VtTablet and MySQL instance. This doc explains interaction happens between and within components.</p>

<p><img src="https://raw.githubusercontent.com/youtube/vitess/master/doc/life_of_a_query.png" alt=""></p>

<p>At a very high level, as the graph shows, first client sends a query to VtGate. VtGate then resolves the query and routes it to the right VtTablets. For each VtTablet that receives the query, it does necessary validations and passes the query to underlying MySQL instance. After gathering results from MySQL, VtTablet sends response back to VtGate. Once VtGate receives response from all VtTablets, it sends the combined result to client. In the presence of VtTablet errors, VtGate will retry the query if errors are recoverable and it only fails the query if either errors are unrecoverable or maximum retry times has been reached.</p>

<h2 id="from-client-to-vtgate">From Client to VtGate</h2>

<p>A client application first sends a bson rpc with an embedded sql query to VtGate. VtGate&#39;s rpc server unmarshals this rpc request, call appropriate VtGate method and return its result back to client. As following graph shows, VtGate has a rpc server that listens to localhost:port/_bson_rpc_ for http requests and localhost:port/_bson_rpc_/auth for https requests.</p>

<p><img src="https://raw.githubusercontent.com/youtube/vitess/master/doc/life_of_a_query_client_to_vtgate.png" alt=""></p>

<p>VtGate keeps an in-memory table that stores all available rpc methods for each service, e.g. VtGate uses &quot;VTGate&quot; as its service name and most its methods defined in <a href="../go/vt/vtgate/vtgate.go">go/vt/vtgate/vtgate.go</a> are used to serve rpc request <a href="../go/rpcplus/server.go">go/rpcplus/server.go</a>.</p>

<h2 id="from-vtgate-to-vttablet">From VtGate to VtTablet</h2>

<p><img src="https://raw.githubusercontent.com/youtube/vitess/master/doc/life_of_a_query_vtgate_to_vttablet.png" alt=""></p>

<p>After receiving a rpc call from client and one of its Execute* method being invoked, VtGate needs to figure out which shards should receive the query and send query to each of them. In addition, VtGate talks to topo server to get necessary information to create a VtTablet connection for each shard. At this point, VtGate is able to send query to the right VtTablets in parallel. VtGate also does retry if timeout happens or some VtTablets return recoverable errors.</p>

<p>Internally, VtGate has a ScatterConn instance and uses it to execute queries across multiple ShardConn connections. A ScatterConn performs the query on selected shards in parallel. It first obtains a ShardConn connection for every shard and sends query use ShardConn&#39;s execute method. If the requested session is in a transaction, it will open a new transactions on the connection, and updates the Session with the transaction id. If the session already contains a transaction id for the shard, it reuses it. If there are any unrecoverable errors during a transaction, it rolls back the transaction for all shards.</p>

<p>A ShardConn object represents a load balanced connection to a group of VtTablets that belong the same shard. ShardConn can be concurrently used across goroutines.</p>

<h2 id="from-vttablet-to-mysql">From VtTablet to MySQL</h2>

<p><img src="https://raw.githubusercontent.com/youtube/vitess/master/doc/life_of_a_query_vttablet_to_mysql.png" alt=""></p>

<p>Once received a rpc call from VtGate, VtTablet do a few checks before passing query to MySQL. It first validates the current VtTablet state including sessions id, then generates a query plan and applies predefined query rules and do ACL check. It also checks whether the query hits row cache and returns result immediately if so. In addition, VtTablet consolidates duplicate queries from executing simultaneously and shares results between them. At this point, VtTablet has no way but pass the query down to MySQL layer and waits for the result.</p>

<h2 id="put-it-all-together">Put it all together</h2>

<p><img src="https://raw.githubusercontent.com/youtube/vitess/master/doc/life_of_a_query_all.png" alt=""></p>

<h2 id="toposerver">TopoServer</h2>

<p>A topo server stores information to help VtGate navigate query to the right VtTablets. It contains keyspace to shards mappings, keyspace id to shard mapping and ports that a VtTablet listens to (EndPoint). VtGates caches those information in the memory and periodically do updates if there are changes happened in the topo server.</p>

<h2 id="streaming-query">Streaming Query</h2>

<p>In general speaking, a streaming query means query results will be returned as a stream. In Vitess&#39;s case, both VtGate and VtTablet will send result back as soon as it is available. VtTablet by default will collect a fixed number of rows returned from MySQL, send them back to VtGate and repeats the above step until all rows have been returned.</p>

<h2 id="scatter-query">Scatter Query</h2>

<p>A scatter query, as its name indicates, will hit multiple shards. In Vitess, a scatter query is recognized once VtGate determines a query need to hit multiple VtTablets. VtGate then sends query to these VtTablets, assembles the result after receiving all response and returns the combined result to the client.</p>

<h2 id="misc">Misc</h2>

<h3 id="rpc-server-code-path-(vtgate)">Rpc Server Code Path (VtGate)</h3>

<p>Init a rpc server</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">go/cmd/vtgate/vtgate.go: main()  -&gt;
  go/vt/servenv/servenv.go: RunDefault() -&gt; // use the port specified in command line &quot;--port&quot;
    go/vt/servenv/run.go: Run(port int)  -&gt;
      go/vt/servenv/rpc.go: ServeRPC()  -&gt; // set up rpc server
        go/rpcwrap/bsonrpc/codec.go: ServeRPC()  -&gt; // set up bson rpc server
          go/rpcwrap/rpcwrap.go: ServeRPC(&quot;bson&quot;, NewServerCodec)  -&gt; // common code to register rpc server
</code></pre></div>
<p>ServeRPC(&quot;bson&quot;, NewServerCodec) register a rpcHandler instance whose ServeHTTP(http.ResponseWriter, *http.Request) will be called for every http request</p>

<p>Rpc server handle http request</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">go/rpcwrap/rpcwrap.go rpcHandler.ServeHTTP -&gt;
go/rpcwrap/rpcwrap.go rpcHandler.server.ServeCodecWithContext -&gt;
go/rpcplus/server.go Server.ServeCodecWithContext(context.Context, ServerCodec) (note: rpcHandler uses a global DefaultServer instance defined in the sever.go) -&gt;
go/rpcplus/server.go Server.readRequest(ServeCodec) will use a given codec to extract (service, methodType, request, request arguments, reply value, keep reading), go/rpcplus/server.go
Finally we do &quot;service.call(..)&quot; with parameters provided in the request. In the current setup, service.call will always call some method in VtGate (go/vt/vtgate/vtgate.go).
</code></pre></div>
<h3 id="vtgate-to-vttablet-code-path">VtGate to VtTablet Code Path</h3>

<p>Here is the code path for a query with keyspace id.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">go/vt/vtgate/vtgate.go VTGate.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery, *proto.QueryResult) -&gt;
  go/vt/vtgate/resolver.go resolver.ExecuteKeyspaceIds(context.Context, *proto.KeyspaceIdQuery) -&gt;
    go/vt/vtgate/resolver.go resolver.Execute -&gt;
      go/vt/vtgate/scatter_conn.go ScatterConn.Execute -&gt;
        go/vt/vtgate/scatter_conn.go ScatterConn.multiGo -&gt;
          go/vt/vtgate/scatter_conn.go ScatterConn.getConnection -&gt;
          go/vt/vtgate/shard_conn.go ShardConn.Execute -&gt;
            go/vt/vtgate/shard_conn.go ShardConn.withRetry -&gt;
              go/vt/vtgate/shard_conn.go ShardConn.getConn -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.GetDialer -&gt;
              go/vt/tabletserver/tabletconn/tablet_conn.go tabletconn.TabletConn.Execute -&gt;
              go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.Execute -&gt;
                go/vt/tabletserver/gorpctabletconn/conn.go TabletBson.rpcClient.Call -&gt;
                go/rpcplus/client.go rpcplus.Client.Call -&gt;
                  go/rpcplus/client.go rpcplus.Client.Go -&gt;
                    go/rpcplus/client.go rpcplus.Client.send
</code></pre></div>
<h3 id="vttablet-to-mysql-code-path">VtTablet to MySQL Code Path</h3>

<p>Here is the code path for a select query.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">go/vt/tabletserver/sqlquery.go SqlQuery.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.Execute -&gt;
go/vt/tabletserver/query_executor.go QueryExecutor.execSelect -&gt;
go/vt/tabletserver/request_context.go RequestContext.getConn -&gt; // QueryExecutor composes a RequestContext
go/vt/tabletserver/request_context.go RequestContext.fullFetch -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQL -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLNoPanic -&gt;
go/vt/tabletserver/request_context.go RequestContext.execSQLOnce -&gt;
go/vt/dbconnpool/connection_pool.go PoolConnection.ExecuteFetch (current implementation is in DBConnection) -&gt;
go/vt/dbconnpool/connection.go PooledConnection.DBConnection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.ExecuteFetch -&gt;
go/mysql/mysql.go mysql.Connection.fetchAll
</code></pre></div>
	<hr />
	<footer class="page-footer">
	  


<div class="author-image">
	<img src="http://youtube.github.io/vitess/images/" alt="Vitess Team">
</div>
<div class="author-content">
	<h3 class="author-name" >Written by <a href="https://github.com/youtube/vitess" itemprop="author">Vitess Team</a></h3>
	<p class="author-bio"></p>
</div>

	  <div class="inline-btn">
	<a class="btn-social twitter" href="https://twitter.com/intent/tweet?text=Life%20of%20A%20Query&amp;url=http://youtube.github.io/vitess/documentation/life-of-a-query/&amp;via=" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i> Share on Twitter</a>
	<a class="btn-social facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://youtube.github.io/vitess/documentation/life-of-a-query/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i> Share on Facebook</a>
	<a class="btn-social google-plus"  href="https://plus.google.com/share?url=http://youtube.github.io/vitess/documentation/life-of-a-query/" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i> Share on Google+</a>
</div>

	  <div class="page-meta">
	<p>Updated <time datetime="2015-01-01T00:00:00Z" itemprop="datePublished">January 01, 2015</time></p>
</div>

	</footer>
	<aside>
	  
	</aside>
      </div>
    </div>
  </article>
</div>


      <footer role="contentinfo" id="site-footer">
  <nav role="navigation" class="menu bottom-menu">
    <ul class="menu-item">
      
      
        
      
      <li><a href="http://youtube.github.io/vitess/" >Home</a></li>
      
      
        
      
      <li><a href="http://youtube.github.io/vitess/getting-started/" >Getting Started</a></li>
      
      
        
      
      <li><a href="http://youtube.github.io/vitess/about/" >About</a></li>
      
      
        
      
      <li><a href="http://youtube.github.io/vitess/faq/" >FAQ</a></li>
      
      
        
      
      <li><a href="http://youtube.github.io/vitess/terms/" >Terms</a></li>
      
    </ul>
  </nav>
  <p class="copyright">&#169; 2015 <a href="http://youtube.github.io/vitess">Vitess</a> powered by <a href="http://www.google.com">Google Inc</a>.</p>
</footer>

    </div>

    <script src="http://youtube.github.io/vitess/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="http://youtube.github.io/vitess/js/main.js"></script>
    
    
    <script type="text/javascript">
      $('.toc').toc({
        'selectors': 'h2', //elements to use as headings
        'container': '.page-content', //element to find all selectors in
        'smoothScrolling': true, //enable or disable smooth scrolling on click
        'prefix': 'toc', //prefix for anchor tags and class names
        'onHighlight': function(el) {}, //called when a new section is highlighted 
        'highlightOnScroll': true, //add class to heading that is currently in focus
        'highlightOffset': 100, //offset to trigger the next headline
        'anchorName': function(i, heading, prefix) { //custom function for anchor name
          return prefix+i;
        },
        'headerText': function(i, heading, $heading) { //custom function building the header-item text
          return $heading.text();
        },
        'itemClass': function(i, heading, $heading, prefix) { //custom function for item class
          return $heading[0].tagName.toLowerCase();
        }
      });
    </script>
    

  </body>

</html>
