<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Reparenting • Vitess</title>
    <meta name="description" content="Reparenting

This document describes the reparenting features of Vitess. Reparenting is used when the master for a Shard is
changing from one host to another. It can be triggered (for maintenance for instance) or happen automatically
(based on the current master dying for instance).

Two main types of reparenting supported by Vitess are Active Reparents (the Vitess toolchain is handing it all)
and External Reparents (another tool is responsible for reparenting, and the Vitess toolchain just update its
internal state.

Active Reparents

They are triggered by using the &#39;vtctl ReparentShard&#39; command. See the help for that command. It currently doesn&#39;t use transaction GroupId.

External Reparents

In this part, we assume another tool has been reparenting our servers. We then trigger the
&#39;vtctl TabletExternallyReparented&#39; command.

The flow for that command is as follows:
- the shard is locked in the global topology server.
- we read the Shard object from the global topology server.
- we read all the tablets in the replication graph for the shard. Note we allow partial reads here, so if a data center is down, as long as the data center containing the new master is up, we keep going.
- the new master performs a &#39;SlaveWasPromoted&#39; action. This remote action makes sure the new master is not a MySQL slave of another server (the &#39;show slave status&#39; command should not return anything, meaning &#39;reset slave&#39; should ave been called).
- for every host in the replication graph, we call the &#39;SlaveWasRestarted&#39; action. It takes as paremeter the address of the new master. On each slave, we update the topology server record for that tablet with the new master, and the replication graph for that tablet as well.
- for the old master, if it doesn&#39;t successfully return from &#39;SlaveWasRestarted&#39;, we change its type to &#39;spare&#39; (so a dead old master doesn&#39;t interfere).
- we then update the Shard object with the new master.
- we rebuild the serving graph for that shard. This will update the &#39;master&#39; record for sure, and also keep all the tablets that have successfully reparented.

Failure cases:
- The global topology server has to be available for locking and modification during this operation. If not, the operation will just fail.
- If a single topology server is down in one data center (and it&#39;s nto the master data center), the tablets in that data center will be ignored by the reparent. When the topology server comes back up, just re-run &#39;vtctl InitTablet&#39; on the tablets, and that will fix their master record.

Reparenting And Serving Graph

When reparenting, we shuffle servers around. A server may get demoted, another promoted, and some servers may end up with the wrong master in the replication graph, or scrapped.

It is important to understand that when we build the serving graph, we go through all the servers in the replication graph, and check their masters. If their master is the one we expect (because it is in the Shard record), we keep going and add them to the serving graph. If not, they are skipped, and a warning is displayed.

When such a slave with the wrong master is present, re-running &#39;vtclt InitTablet&#39; with the right parameters will fix the server. So the order of operations should be to fix mysql replication, make sure it is caught up, run &#39;vtctl InitTablet&#39;, and maybe restart vttablet if needed.

Alternatively, if another reparent happens, and the bad slave recovers and now replicates from the new master, it will be re-added, and resume proper operation.

The old master for reparenting is a specific case. If it doesn&#39;t have the right master during the reparent, it will be scrapped (because it&#39;s not in the replication graph at all, so it would get lost anyway).
">
    <meta name="keywords" content="">
    
    
    	<!-- Twitter Cards -->
	<meta name="twitter:title" content="Reparenting">
	<meta name="twitter:description" content="Reparenting

This document describes the reparenting features of Vitess. Reparenting is used when the master for a Shard is
changing from one host to another. It can be triggered (for maintenance for instance) or happen automatically
(based on the current master dying for instance).

Two main types of reparenting supported by Vitess are Active Reparents (the Vitess toolchain is handing it all)
and External Reparents (another tool is responsible for reparenting, and the Vitess toolchain just update its
internal state.

Active Reparents

They are triggered by using the &#39;vtctl ReparentShard&#39; command. See the help for that command. It currently doesn&#39;t use transaction GroupId.

External Reparents

In this part, we assume another tool has been reparenting our servers. We then trigger the
&#39;vtctl TabletExternallyReparented&#39; command.

The flow for that command is as follows:
- the shard is locked in the global topology server.
- we read the Shard object from the global topology server.
- we read all the tablets in the replication graph for the shard. Note we allow partial reads here, so if a data center is down, as long as the data center containing the new master is up, we keep going.
- the new master performs a &#39;SlaveWasPromoted&#39; action. This remote action makes sure the new master is not a MySQL slave of another server (the &#39;show slave status&#39; command should not return anything, meaning &#39;reset slave&#39; should ave been called).
- for every host in the replication graph, we call the &#39;SlaveWasRestarted&#39; action. It takes as paremeter the address of the new master. On each slave, we update the topology server record for that tablet with the new master, and the replication graph for that tablet as well.
- for the old master, if it doesn&#39;t successfully return from &#39;SlaveWasRestarted&#39;, we change its type to &#39;spare&#39; (so a dead old master doesn&#39;t interfere).
- we then update the Shard object with the new master.
- we rebuild the serving graph for that shard. This will update the &#39;master&#39; record for sure, and also keep all the tablets that have successfully reparented.

Failure cases:
- The global topology server has to be available for locking and modification during this operation. If not, the operation will just fail.
- If a single topology server is down in one data center (and it&#39;s nto the master data center), the tablets in that data center will be ignored by the reparent. When the topology server comes back up, just re-run &#39;vtctl InitTablet&#39; on the tablets, and that will fix their master record.

Reparenting And Serving Graph

When reparenting, we shuffle servers around. A server may get demoted, another promoted, and some servers may end up with the wrong master in the replication graph, or scrapped.

It is important to understand that when we build the serving graph, we go through all the servers in the replication graph, and check their masters. If their master is the one we expect (because it is in the Shard record), we keep going and add them to the serving graph. If not, they are skipped, and a warning is displayed.

When such a slave with the wrong master is present, re-running &#39;vtclt InitTablet&#39; with the right parameters will fix the server. So the order of operations should be to fix mysql replication, make sure it is caught up, run &#39;vtctl InitTablet&#39;, and maybe restart vttablet if needed.

Alternatively, if another reparent happens, and the bad slave recovers and now replicates from the new master, it will be re-added, and resume proper operation.

The old master for reparenting is a specific case. If it doesn&#39;t have the right master during the reparent, it will be scrapped (because it&#39;s not in the replication graph at all, so it would get lost anyway).
">
	
	
	
	<meta name="twitter:card" content="summary">
	<meta name="twitter:image" content="http://vitess.io/images/120x120.gif">
	
	<!-- Open Graph -->
	<meta property="og:locale" content="en_US">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Reparenting">
	<meta property="og:description" content="Reparenting

This document describes the reparenting features of Vitess. Reparenting is used when the master for a Shard is
changing from one host to another. It can be triggered (for maintenance for instance) or happen automatically
(based on the current master dying for instance).

Two main types of reparenting supported by Vitess are Active Reparents (the Vitess toolchain is handing it all)
and External Reparents (another tool is responsible for reparenting, and the Vitess toolchain just update its
internal state.

Active Reparents

They are triggered by using the &#39;vtctl ReparentShard&#39; command. See the help for that command. It currently doesn&#39;t use transaction GroupId.

External Reparents

In this part, we assume another tool has been reparenting our servers. We then trigger the
&#39;vtctl TabletExternallyReparented&#39; command.

The flow for that command is as follows:
- the shard is locked in the global topology server.
- we read the Shard object from the global topology server.
- we read all the tablets in the replication graph for the shard. Note we allow partial reads here, so if a data center is down, as long as the data center containing the new master is up, we keep going.
- the new master performs a &#39;SlaveWasPromoted&#39; action. This remote action makes sure the new master is not a MySQL slave of another server (the &#39;show slave status&#39; command should not return anything, meaning &#39;reset slave&#39; should ave been called).
- for every host in the replication graph, we call the &#39;SlaveWasRestarted&#39; action. It takes as paremeter the address of the new master. On each slave, we update the topology server record for that tablet with the new master, and the replication graph for that tablet as well.
- for the old master, if it doesn&#39;t successfully return from &#39;SlaveWasRestarted&#39;, we change its type to &#39;spare&#39; (so a dead old master doesn&#39;t interfere).
- we then update the Shard object with the new master.
- we rebuild the serving graph for that shard. This will update the &#39;master&#39; record for sure, and also keep all the tablets that have successfully reparented.

Failure cases:
- The global topology server has to be available for locking and modification during this operation. If not, the operation will just fail.
- If a single topology server is down in one data center (and it&#39;s nto the master data center), the tablets in that data center will be ignored by the reparent. When the topology server comes back up, just re-run &#39;vtctl InitTablet&#39; on the tablets, and that will fix their master record.

Reparenting And Serving Graph

When reparenting, we shuffle servers around. A server may get demoted, another promoted, and some servers may end up with the wrong master in the replication graph, or scrapped.

It is important to understand that when we build the serving graph, we go through all the servers in the replication graph, and check their masters. If their master is the one we expect (because it is in the Shard record), we keep going and add them to the serving graph. If not, they are skipped, and a warning is displayed.

When such a slave with the wrong master is present, re-running &#39;vtclt InitTablet&#39; with the right parameters will fix the server. So the order of operations should be to fix mysql replication, make sure it is caught up, run &#39;vtctl InitTablet&#39;, and maybe restart vttablet if needed.

Alternatively, if another reparent happens, and the bad slave recovers and now replicates from the new master, it will be re-added, and resume proper operation.

The old master for reparenting is a specific case. If it doesn&#39;t have the right master during the reparent, it will be scrapped (because it&#39;s not in the replication graph at all, so it would get lost anyway).
">
	<meta property="og:url" content="http://vitess.io/doc/Reparenting/">
	<meta property="og:site_name" content="Vitess">

    <link rel="canonical" href="http://vitess.io/doc/Reparenting/">

    <link href="http://vitess.io/sitemap.xml" type="application/xml" rel="sitemap" title="Sitemap">

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cleartype" content="on">

    <style>
    .sliding-menu-content {
      top: 0;
      right: 0;
      text-align: center;
      visibility: hidden;
      height: 100%;
      width: 100%;
      -webkit-transform: translateX(100%);
      -moz-transform: translateX(100%);
      -ms-transform: translateX(100%);
      -o-transform: translateX(100%);
      transform: translateX(100%);
    }
    </style>

    <link rel="stylesheet" href="http://vitess.io/css/main.css">
    <!-- HTML5 Shiv and Media Query Support for IE -->
    <!--[if lt IE 9]>
      <script src="http://vitess.io/js/vendor/html5shiv.min.js"></script>
      <script src="http://vitess.io/js/vendor/respond.min.js"></script>
    <![endif]-->

  </head>

  <body>
    <header id="masthead">
  <div class="inner-wrap">
    <a href="http://vitess.io/" class="site-title">Vitess</a>
    <nav role="navigation" class="menu top-menu">
        <ul class="menu-item">
	<li class="home"><a href="/">Vitess</a></li>
	
    
        
    
    <li><a href="http://vitess.io/getting-started/" >Getting Started</a></li>
  
    
        
    
    <li><a href="http://vitess.io/doc/" >Documentation</a></li>
  
    
        
    
    <li><a href="http://vitess.io/about/" >About</a></li>
  
    
        
    
    <li><a href="http://vitess.io/faq/" >FAQ</a></li>
  
</ul>
    </nav>
  </div>
</header>

    <nav role="navigation" class="js-menu sliding-menu-content">
	<ul class="menu-item">
		<li>
      
        
      
			<a href="http://vitess.io/getting-started/"><img src="http://vitess.io/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://vitess.io/getting-started/" class="title">Getting Started</a>
			<p class="excerpt">Everything you need to know to get started with Vitess.</p>
		</li><li>
      
        
      
			<a href="http://vitess.io/doc/"><img src="http://vitess.io/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://vitess.io/doc/" class="title">Documentation</a>
			<p class="excerpt">Vitess Docs.</p>
		</li><li>
      
        
      
			<a href="http://vitess.io/about/"><img src="http://vitess.io/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://vitess.io/about/" class="title">About</a>
			<p class="excerpt">All about Vitess.</p>
		</li><li>
      
        
      
			<a href="http://vitess.io/faq/"><img src="http://vitess.io/images/400x250.gif" alt="teaser" class="teaser"></a>
			<a href="http://vitess.io/faq/" class="title">FAQ</a>
			<p class="excerpt">Vitess Faq.</p>
		</li>
	</ul>
</nav>
<button type="button" class="js-menu-trigger sliding-menu-button menulines-button x2" role="button" aria-label="Toggle Navigation">
	<span class="menulines"></span>
</button>

<div class="js-menu-screen menu-screen"></div>

    <div id="page-wrapper">
      <!--[if lt IE 9]><div class="upgrade notice-danger"><strong>Your browser is quite old!</strong> Why not <a href="http://whatbrowser.org/">upgrade to a newer one</a> to better enjoy this site?</div><![endif]-->

      <div id="main" role="main">
  <article class="wrap" itemscope itemtype="http://schema.org/Article">
    
    
  <nav class="breadcrumbs">
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://vitess.io" itemprop="url">
        <span itemprop="title">Home</span>
      </a> › 
    <span itemscope itemtype="http://data-vocabulary.org/Breadcrumb">
      <a href="http://vitess.io/doc/" itemprop="url">
        <span itemprop="title">Doc</span>
      </a>
    </span>
  </nav>


    <div class="inner-wrap">
      <nav class="toc"></nav>
      <div id="content" class="page-content" itemprop="articleBody">
	<h1 id="reparenting">Reparenting</h1>

<p>This document describes the reparenting features of Vitess. Reparenting is used when the master for a Shard is
changing from one host to another. It can be triggered (for maintenance for instance) or happen automatically
(based on the current master dying for instance).</p>

<p>Two main types of reparenting supported by Vitess are Active Reparents (the Vitess toolchain is handing it all)
and External Reparents (another tool is responsible for reparenting, and the Vitess toolchain just update its
internal state.</p>

<h2 id="active-reparents">Active Reparents</h2>

<p>They are triggered by using the &#39;vtctl ReparentShard&#39; command. See the help for that command. It currently doesn&#39;t use transaction GroupId.</p>

<h2 id="external-reparents">External Reparents</h2>

<p>In this part, we assume another tool has been reparenting our servers. We then trigger the
&#39;vtctl TabletExternallyReparented&#39; command.</p>

<p>The flow for that command is as follows:
- the shard is locked in the global topology server.
- we read the Shard object from the global topology server.
- we read all the tablets in the replication graph for the shard. Note we allow partial reads here, so if a data center is down, as long as the data center containing the new master is up, we keep going.
- the new master performs a &#39;SlaveWasPromoted&#39; action. This remote action makes sure the new master is not a MySQL slave of another server (the &#39;show slave status&#39; command should not return anything, meaning &#39;reset slave&#39; should ave been called).
- for every host in the replication graph, we call the &#39;SlaveWasRestarted&#39; action. It takes as paremeter the address of the new master. On each slave, we update the topology server record for that tablet with the new master, and the replication graph for that tablet as well.
- for the old master, if it doesn&#39;t successfully return from &#39;SlaveWasRestarted&#39;, we change its type to &#39;spare&#39; (so a dead old master doesn&#39;t interfere).
- we then update the Shard object with the new master.
- we rebuild the serving graph for that shard. This will update the &#39;master&#39; record for sure, and also keep all the tablets that have successfully reparented.</p>

<p>Failure cases:
- The global topology server has to be available for locking and modification during this operation. If not, the operation will just fail.
- If a single topology server is down in one data center (and it&#39;s nto the master data center), the tablets in that data center will be ignored by the reparent. When the topology server comes back up, just re-run &#39;vtctl InitTablet&#39; on the tablets, and that will fix their master record.</p>

<h2 id="reparenting-and-serving-graph">Reparenting And Serving Graph</h2>

<p>When reparenting, we shuffle servers around. A server may get demoted, another promoted, and some servers may end up with the wrong master in the replication graph, or scrapped.</p>

<p>It is important to understand that when we build the serving graph, we go through all the servers in the replication graph, and check their masters. If their master is the one we expect (because it is in the Shard record), we keep going and add them to the serving graph. If not, they are skipped, and a warning is displayed.</p>

<p>When such a slave with the wrong master is present, re-running &#39;vtclt InitTablet&#39; with the right parameters will fix the server. So the order of operations should be to fix mysql replication, make sure it is caught up, run &#39;vtctl InitTablet&#39;, and maybe restart vttablet if needed.</p>

<p>Alternatively, if another reparent happens, and the bad slave recovers and now replicates from the new master, it will be re-added, and resume proper operation.</p>

<p>The old master for reparenting is a specific case. If it doesn&#39;t have the right master during the reparent, it will be scrapped (because it&#39;s not in the replication graph at all, so it would get lost anyway).</p>

	<hr />
	<footer class="page-footer">
	  


<div class="author-image">
	<img src="http://vitess.io/images/" alt="Vitess Team">
</div>
<div class="author-content">
	<h3 class="author-name" >Written by <a href="https://github.com/youtube/vitess" itemprop="author">Vitess Team</a></h3>
	<p class="author-bio"></p>
</div>

	  <div class="inline-btn">
	<a class="btn-social twitter" href="https://twitter.com/intent/tweet?text=Reparenting&amp;url=http://vitess.io/doc/Reparenting/&amp;via=" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i> Share on Twitter</a>
	<a class="btn-social facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://vitess.io/doc/Reparenting/" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i> Share on Facebook</a>
	<a class="btn-social google-plus"  href="https://plus.google.com/share?url=http://vitess.io/doc/Reparenting/" target="_blank"><i class="fa fa-google-plus" aria-hidden="true"></i> Share on Google+</a>
</div>

	  <div class="page-meta">
	<p>Updated <time datetime="2015-01-01T00:00:00Z" itemprop="datePublished">January 01, 2015</time></p>
</div>

	</footer>
	<aside>
	  
	</aside>
      </div>
    </div>
  </article>
</div>


      <footer role="contentinfo" id="site-footer">
  <nav role="navigation" class="menu bottom-menu">
    <ul class="menu-item">
      
      
        
      
      <li><a href="http://vitess.io/" >Home</a></li>
      
      
        
      
      <li><a href="http://vitess.io/getting-started/" >Getting Started</a></li>
      
      
        
      
      <li><a href="http://vitess.io/about/" >About</a></li>
      
      
        
      
      <li><a href="http://vitess.io/faq/" >FAQ</a></li>
      
      
        
      
      <li><a href="http://vitess.io/terms/" >Terms</a></li>
      
    </ul>
  </nav>
  <p class="copyright">&#169; 2015 <a href="http://vitess.io">Vitess</a> powered by <a href="http://www.google.com">Google Inc</a>.</p>
</footer>

    </div>

    <script src="http://vitess.io/js/vendor/jquery-1.9.1.min.js"></script>
    <script src="http://vitess.io/js/main.js"></script>
    
    
    <script type="text/javascript">
      $('.toc').toc({
        'selectors': 'h2', //elements to use as headings
        'container': '.page-content', //element to find all selectors in
        'smoothScrolling': true, //enable or disable smooth scrolling on click
        'prefix': 'toc', //prefix for anchor tags and class names
        'onHighlight': function(el) {}, //called when a new section is highlighted 
        'highlightOnScroll': true, //add class to heading that is currently in focus
        'highlightOffset': 100, //offset to trigger the next headline
        'anchorName': function(i, heading, prefix) { //custom function for anchor name
          return prefix+i;
        },
        'headerText': function(i, heading, $heading) { //custom function building the header-item text
          return $heading.text();
        },
        'itemClass': function(i, heading, $heading, prefix) { //custom function for item class
          return $heading[0].tagName.toLowerCase();
        }
      });
    </script>
    

  </body>

</html>
